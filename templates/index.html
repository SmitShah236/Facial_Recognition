<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Face Match</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        h1 { margin-bottom: 10px; }
        .message { margin: 20px 0; font-size: 18px; }
        .error { color: red; }
        .success { color: green; }
        .match-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .match-item { text-align: center; }
        .match-item img, .match-item video {
            max-width: 300px;
            max-height: 300px;
            border: 2px solid #ccc;
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>Upload or Capture a Face</h1>

    {% if message %}
        <div class="message {{ 'error' if error else 'success' }}">{{ message }}</div>
    {% endif %}

    {% if matches %}
        <div class="match-grid">
            {% for match in matches %}
                <div class="match-item">
                    {% if match.type == 'image' %}
                    <img src="{{ url_for('serve_media', subpath=match['path'].replace('\\', '/')) }}" alt="Matched Face">
                    <div>Matched Image</div>
                    {% elif match.type == 'video' %}
                        <video controls>
                            <source src="{{ url_for('serve_media', filename=match.path.replace('\\', '/')) | replace(' ', '%20') }}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div>Matched Video</div>
                    {% endif %}
                </div>
            {% endfor %}
        </div>
    {% endif %}

    <form id="imageForm" action="/upload" method="POST" enctype="multipart/form-data">
        <label for="imageUpload">Choose an image or use webcam:</label>
        <input type="file" id="imageUpload" name="image" accept="image/*">
        <p id="fileError" style="color:red; display:none;">Please select or capture an image first!</p>

        <div style="margin-top: 10px;">
            <button type="button" id="startWebcam">Start Webcam</button>
            <video id="webcam" autoplay playsinline style="display: none;"></video>
            <button type="button" id="captureButton" style="display: none;">Capture</button>
            <canvas id="canvas" style="display: none;"></canvas>
        </div>

        <div style="margin-top: 10px;">
            <button type="submit">Submit</button>
        </div>
    </form>

    <script>
        const startWebcamBtn = document.getElementById('startWebcam');
        const captureBtn = document.getElementById('captureButton');
        const webcam = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const imageUpload = document.getElementById('imageUpload');
        const fileError = document.getElementById('fileError');
        const form = document.getElementById('imageForm');

        let stream;

        startWebcamBtn.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcam.srcObject = stream;
                webcam.style.display = 'block';
                captureBtn.style.display = 'inline';
                startWebcamBtn.style.display = 'none';
            } catch (err) {
                alert("Unable to access webcam: " + err);
            }
        });

        captureBtn.addEventListener('click', () => {
            const context = canvas.getContext('2d');
            canvas.width = webcam.videoWidth;
            canvas.height = webcam.videoHeight;
            context.drawImage(webcam, 0, 0);

            const originalDataUrl = canvas.toDataURL('image/png');

            resizeAndCompress(originalDataUrl, 800, 800, function (compressedDataUrl) {
                const file = dataUrlToFile(compressedDataUrl, 'captured.jpg');
                const dt = new DataTransfer();
                dt.items.add(file);
                imageUpload.files = dt.files;
            });

            stream.getTracks().forEach(track => track.stop());
            webcam.style.display = 'none';
            captureBtn.style.display = 'none';
        });

        form.addEventListener('submit', function (e) {
            if (!imageUpload.files.length) {
                e.preventDefault();
                fileError.style.display = 'block';
            }
        });

        function resizeAndCompress(base64, maxW, maxH, callback) {
            const img = new Image();
            img.onload = function () {
                let w = img.width;
                let h = img.height;

                if (w > maxW || h > maxH) {
                    if (w > h) {
                        h *= maxW / w;
                        w = maxW;
                    } else {
                        w *= maxH / h;
                        h = maxH;
                    }
                }

                const resizeCanvas = document.createElement('canvas');
                resizeCanvas.width = w;
                resizeCanvas.height = h;
                const ctx = resizeCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0, w, h);

                const compressed = resizeCanvas.toDataURL('image/jpeg', 0.8);
                callback(compressed);
            };
            img.src = base64;
        }

        function dataUrlToFile(dataUrl, filename = 'image.jpg') {
            const [meta, base64] = dataUrl.split(',');
            const mime = meta.match(/:(.*?);/)[1];
            const binary = atob(base64);
            const array = [];
            for (let i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            return new File([new Uint8Array(array)], filename, { type: mime });
        }
    </script>
</body>
</html>
